package Sort;

public class SelectionSort {
	
	/*
		Selection Sort(선택정렬)
		현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘
		최대(DESC)나 최소(ASC) 데이터를 찾아서 아직 정렬되지 않은 남은 정렬 부분의 가장 앞에 있는 데이터와 swap한다.
		
		비교   정렬 : 데이터를 비교하면서 찾는다. 
		제자리 정렬 : 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지않는다.(swap임시변수 무시 가능)
		불안정 정렬 : ?
		
		불안정 정렬에 이해를 위한 예시 -> 정렬 결과가 안정적이지 않다. 
		
		[예시 1]
		[B1, B2, C, A] (A < B < C, B1==B2 구분을 위해 첨자를 붙인 것)
		round 1 : [A, B2, C, B1]
		round 2 : [A, B2, C, B1]
		round 3 : [A, B2, B1, C] -> 정렬 끝
		초기의 B1, B2의 순서가 뒤바뀌었다. 
		[예시 2]
		[(가영,60), (가희,60), (찬호,70), (동우,45)] 성적순으로 정리하되, 동점자는 이름 순으로 정렬하기 
		
		1. 이름순으로 먼저 정렬
		[(가영,60), (가희,60), (동우,45), (찬호,70)]
		2. 선택정렬 시작
		round 1 : [(동우,45), (가희,60), (가영,60), (찬호,70)]
		round 2 : [(동우,45), (가희,60), (가영,60), (찬호,70)]
		round 3 : [(동우,45), (가희,60), (가영,60), (찬호,70)] -> 정렬 끝
		원하는 결과와 다른 결과가 나왔다. 불안정하다..

		
		1. 주어진 리스트에서 최소 or 최대값을 찾는다.
		2. 1에서 찾은 값을 남은 정렬부분의 맨 앞 자리 값과 교환한다.
		3. 맨 앞자리를 제외한 나머지 값들 중 최소 or 최대값을 찾아 위의 과정을 반복한다.
		
		EX> N개의 원소를 정렬할 때, 선택정렬은 앞 인덱스부터 순차적으로 정렬해나가기 때문에, N개의 
		데이터 중 N-1개가 정렬되어 있다는 것은 결국 마지막 원소가 최대 or 최소값이라는 말이고, 이는 정렬이 되어 
		있다는 말이므로 굳이 마지막 round N을 할 필요가 없다.  
		
		
		[장점] 
		1. 추가적인 메모리 소비가 작다. 
		
		[단점]
		1. 시간복잡도가 O(N^2)이다. 
		2. 안정 정렬이 아니다. 
		
		정렬대상인 데이터 수 N, 라운드 i
	 	i=1일 때, 데이터 비교 횟수 N-1번 
	 	i=2일 때, 데이터 비교 횟수 N-2번 
	 	i=3일 때, 데이터 비교 횟수 N-3번 
	 		.
	 		.
	 		.
	 	i=N-1일 때, 데이터 비교 횟수 1번 
	 	
	 	일반화
	 	ㄴ> i=K일 때, 데이터 비교 횟수 N-K번
	 	
	 	버블정렬과 이론상 같은 시간 복잡도를 가지지만, 비교 수행이 상대적으로 적기(bubble: 현재 원소보다 작으면 계속 swap, selection: 최솟값 1개만 swap) 때문에 비교적 빠르긴 하지만 그럼에도 좋은 알고리즘은 아니다.
	 	
	 	
	 	
	*/
	
	public static void selection_sort(int[] a) {
		selection_sort(a, a.length);
	}

	private static void selection_sort(int[] a, int length) {
		// TODO Auto-generated method stub
		
		//라운드의 수는 배열의크기-1
		for(int i=0; i< length-1;i++) {
			
			//최소 or 최대값을 찾으면 swap해줄 idx
			int min_idx = i;
			
			//최소 or 최대를 갖는 인덱스 찾기
			//정렬되지 않은 가장 처음 idx -> i + 1
			//비교 대상은 배열의 마지막 인덱스 -> length - 1
			for(int j=i+1;j<length;j++ ) {
				//현재 값보다 작은 값이 1개라는 보장이 없기 때문에 배열의 끝까지 비교 수행
				if( a[j] < a[min_idx]) {
					min_idx = j;
				}
			}

				
			//i번째 값과 찾은 최솟값을 서로 교환
			swap(a, min_idx, i); //배열, 최솟값의 idx, 값을 바꿀 위치 i
			
		}
	}

	private static void swap(int[] a, int min_idx, int i) {
		// TODO Auto-generated method stub
		int temp = a[min_idx];
		a[min_idx] = a[i];
		a[i] = temp;
	}

}
